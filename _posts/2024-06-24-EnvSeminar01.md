---
title: "[í™˜ê²½ì„¸ë¯¸ë‚˜] AI í­íƒ„ ì œê±° ë¶€ëŒ€ 01íŒ€"  
excerpt: "ì´ìŠ¹ì—°, ë³€ì§€ì€" # ë¯¸ë¦¬ë³´ê¸°ë¡œ ë³´ì´ëŠ” ë¶€ë¶„  
categories: í”„ë¡œì íŠ¸  
tags: 
    - [ê°•í™”í•™ìŠµ, ì •ê·œì„¸ì…˜, í”„ë¡œì íŠ¸, ì´ìŠ¹ì—°]  
toc: true  
toc_sticky: true  
comments: true  
author: Seungyeon Lee

date: 2024-06-24
---

# init

| input | ê·¸ë¦¬ë“œì›”ë“œ ì‚¬ì´ì¦ˆ, ì§€ë¢° ê°œìˆ˜ |
| --- | --- |

```python
def __init__(self, gridworld_size:Tuple, num_mine:int):

    self.gridworld_size = gridworld_size
    self.nrow, self.ncol = self.gridworld_size
    self.num_mine = num_mine

    # ê·¸ë¦¬ë“œì›”ë“œì˜ ì¢Œí‘œ(íŠœí”Œ)ì˜ ë¦¬ìŠ¤íŠ¸
    # points == action space
    self.points = []
    for i in range(self.nrow):
        for j in range(self.ncol):
            self.points.append((i,j))
    self.num_actions = len(self.points)

    # ë³´ìƒ ë”•ì…”ë„ˆë¦¬
    self.reward_dict = {'mine':-10, 'empty':1, 'clear':10}

    self.points_unvisit = self.points.copy()

    # ì§€ë¢° ëœë¤ìœ¼ë¡œ ë°°ì •
    self.mine_points = random.sample(self.points, self.num_mine)

    # ê·¸ë¦¬ë“œ ì›”ë“œ rendering (ì§€ë¢°: 'M')
    self.gridworld = np.full(shape=(self.nrow, self.ncol), fill_value=".")
    for x,y in self.mine_points:
        self.gridworld[x,y] = 'M'

    # ì§€ë¢° = Trueì¸ ë§µ
  self.mine_bool = (self.gridworld=='M')

    # ì£¼ë³€ ì§€ë¢° ê°œìˆ˜ë¥¼ í‘œì‹œí•œ ë§µ (ì§€ë¢° ìœ„ì¹˜: -1)
    self.map_answer = np.zeros(self.gridworld_size)
    for x,y in self.points:
        cnt = self.check_mine((x,y))
        self.map_answer[x,y] = cnt

    # state ë§µ
    self.present_state = np.full((self.nrow, self.ncol), -2) # BFSë¡œ íƒìƒ‰í•˜ì§€ ì•Šì€ ë¶€ë¶„ì„ -2ë¡œ ì´ˆê¸°í™”
    
    # ë°©ë¬¸ ë§µ(bool)
    self.visited_map = (self.present_state == self.map_answer)
```

---

- ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸
    
    ```python
    self.points = []
    for i in range(self.nrow):
        for j in range(self.ncol):
            self.points.append((i,j))
    self.num_actions = len(self.points)
    ```
    
    - type: `list`
    - ê·¸ë¦¬ë“œ ì›”ë“œì˜ ëª¨ë“  ì¢Œí‘œë¥¼ íŠœí”Œë¡œ ë‹´ì€ ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸
    - `self.points` == Action space
    
    <aside>
    ğŸ“Œ ë¦¬ìŠ¤íŠ¸ â†’ np.array
    ì¸ë±ìŠ¤ ë°©ì‹ìœ¼ë¡œ ë°”ê¾¸ê¸°
    
    </aside>
    
- ë³´ìƒ ë”•ì…”ë„ˆë¦¬
    
    ```python
    # ë³´ìƒ ë”•ì…”ë„ˆë¦¬
    self.reward_dict = {'mine':-10, 'empty':1, 'clear':10}
    ```
    
    - type : `dict`
    - ì§€ë¢° : -10
    - ì§€ë¢°X : 1
    - ê²Œì„ì„ ì„±ê³µí•œ ê²½ìš° : 10
    
    <aside>
    ğŸ“Œ ì´ë¯¸ ê¹Œì§„ íƒ€ì¼ì„ ë‹¤ì‹œ ëˆ„ë¥´ëŠ” ê²½ìš° ìŒìˆ˜ ë³´ìƒ
    ? ê·¼ë° ì´ë¯¸ ê¹Œì§„ íƒ€ì¼ì„ ì•„ì˜ˆ ì•ˆëˆ„ë¥´ë„ë¡ ë§Œë“¤ê³  ìˆëŠ”ë° ëˆ„ë¥¼ ìˆ˜ ìˆë„ë¡ í•´ì•¼í•˜ëŠ”ê±´ê°€
    
    </aside>
    

- ë§µ & ì§€ë¢°
    
    ```python
    self.points_unvisit = self.points.copy()
    ```
    
    - type : `list`
    - ì•¡ì…˜ì— ë”°ë¼ ì´ë¯¸ ë°©ë¬¸í•œ ì¢Œí‘œë¥¼ ì œì™¸í•œ ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸
    
    <aside>
    ğŸ“Œ ì´ê±° ê³ ë¯¼
    
    </aside>
    
    ```python
    self.mine_points = random.sample(self.points, self.num_mine)
    ```
    
    - type : `list`
    - ì£¼ì–´ì§„ ì§€ë¢° ê°œìˆ˜ë§Œí¼ ì§€ë¢°ì˜ ì¢Œí‘œë¥¼ ëœë¤ìœ¼ë¡œ ë½‘ìŒ
    
    ```python
    self.gridworld = np.full(shape=(self.nrow, self.ncol), fill_value=".")
    for x,y in self.mine_points:
        self.gridworld[x,y] = 'M'
    
    self.mine_bool = (self.gridworld=='M')
    ```
    
    - `self.gridworld` : ê·¸ë¦¬ë“œ ì›”ë“œ ë Œë”ë§ (str í˜•ì‹)
        - type : `np.array`
        - ë¹ˆ ê³³ : .
        - ì§€ë¢° : M
    - `self.mine_bool` : ì§€ë¢° ìœ„ì¹˜ë¥¼ Trueë¡œ í•˜ëŠ” ë§µ (bool í˜•ì‹)
    
    ```python
    self.map_answer = np.zeros(self.gridworld_size)
    for x,y in self.points:
        cnt = self.check_mine((x,y))
        self.map_answer[x,y] = cnt
    ```
    
    - `self.map_answer` : ê° ì¢Œí‘œ ë³„ë¡œ ì£¼ë³€ ì§€ë¢° ê°œìˆ˜ë¥¼ ê³„ì‚°í•œ ì •ë‹µ ë§µ
        - type : `np.array`
        - `self.check_mine(ì¢Œí‘œ)` : í´ë˜ìŠ¤ ë‚´ì¥ í•¨ìˆ˜
    
    ```python
    self.present_state = np.full((self.nrow, self.ncol), -2)
    self.visited_map = (self.present_state == self.map_answer)
    ```
    
    - `self.present_state` : ì—ì´ì „íŠ¸ì—ê²Œ ì „ë‹¬í•˜ëŠ” ìƒíƒœ ë§µ
        - type : `np.array`
        - íƒìƒ‰í•˜ì§€ ì•Šì€ ì¢Œí‘œë¥¼ -2ë¡œ í‘œì‹œ
        - ì²˜ìŒì—ëŠ” ì „ë¶€ -2 ìƒíƒœ
    - `self.visited_map` : ë°©ë¬¸ ë§µ. (bool í˜•ì‹)
        - type : `np.array`
        - ë°©ë¬¸í•œ ì¢Œí‘œ : True

# ë§µ ìƒì„± ê´€ë ¨ í•¨ìˆ˜

## check_mine

- í•´ë‹¹ ì¢Œí‘œ ê·¼ì²˜ ì§€ë¢° ê°œìˆ˜ë¥¼ êµ¬í•˜ëŠ” í•¨ìˆ˜
    
    
    | input | ì¢Œí‘œ (Tuple) |
    | --- | --- |
    | output | ì¢Œí‘œ ê·¼ì²˜ 8ì¹¸ì— ìˆëŠ” ì§€ë¢° ê°œìˆ˜ (int) |

```python
def check_mine(self, coord:Tuple):
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1),
                  (-1, -1), (-1, 1), (1, -1), (1, 1)]
        x, y = coord
        result = 0

        if self.mine_bool[x,y]:
            result = -1

        else:
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < self.nrow and 0 <= ny < self.ncol:
                    if self.mine_bool[nx, ny]:
                        result += 1
        return int(result)
```

---

```python
directions = [(-1, 0), (1, 0), (0, -1), (0, 1),
              (-1, -1), (-1, 1), (1, -1), (1, 1)]
x, y = coord
result = 0
```

- `direction` : ì¢Œí‘œ ì£¼ë³€ 8ì¹¸ì„ íƒìƒ‰í•˜ê¸° ìœ„í•œ ë¦¬ìŠ¤íŠ¸
- `x`, `y` : ì…ë ¥ë°›ì€ ì¢Œí‘œë¥¼ ë„£ìŒ
- `result` : ì£¼ë³€ ì§€ë¢° ê°œìˆ˜ (ì´ˆê¸°ê°’ : 0)

```python
if self.mine_bool[x,y]:
		result = -1
```

- í•´ë‹¹ ì¢Œí‘œê°€ ì§€ë¢°ì¸ ê²½ìš° -1 ë°˜í™˜

```python
else:
    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < self.nrow and 0 <= ny < self.ncol:
            if self.mine_bool[nx, ny]:
                result += 1
```

- ì£¼ì–´ì§„ ì¢Œí‘œì˜ ì£¼ë³€ 8ì¹¸ì„ íƒìƒ‰í•˜ë©° ë§Œì•½ íƒìƒ‰í•œ ì¢Œí‘œì— ì§€ë¢°ê°€ ìˆìœ¼ë©´ resultì— +1
    - ë§µ ê°€ì¥ìë¦¬ ê³ ë ¤

## bfs_minesweeper

- ê°€ë ¤ì ¸ìˆëŠ” ë§µì—ì„œ í´ë¦­í•  ì¢Œí‘œì— ë”°ë¼ ë§µì„ ì—´ì–´ì£¼ëŠ” í•¨ìˆ˜
    
    
    | input | í´ë¦­í•  ì¢Œí‘œ(Tuple) |
    | --- | --- |
    | output | í´ë¦­í•œ ì¢Œí‘œì— ë”°ë¼ì„œ ì—´ë¦° ë§µ(array) |

```python
def bfs_minesweeper(self, clicked_point:Tuple):
    queue = deque([clicked_point])
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1),
                (-1, -1), (-1, 1), (1, -1), (1, 1)]

    # ë°©ë¬¸ ë§µ(bool)
    visited = self.visited_map.copy()

    result = self.present_state.copy()

    while queue:
        x, y = queue.popleft()
        if visited[x, y]:
            continue
        visited[x, y] = True
        result[x, y] = self.map_answer[x, y]

        if self.map_answer[x,y] == 0:
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < self.nrow and 0 <= ny < self.ncol and not visited[nx, ny]:
                    queue.append((nx, ny))

		self.visited_map = visited
		
    return result

```

---

```python
directions = [(-1, 0), (1, 0), (0, -1), (0, 1),
                (-1, -1), (-1, 1), (1, -1), (1, 1)]
visited = self.visited_map.copy()
result = self.present_state.copy()
```

- `direction` : ì¢Œí‘œ ì£¼ë³€ 8ì¹¸ì„ íƒìƒ‰í•˜ê¸° ìœ„í•œ ë¦¬ìŠ¤íŠ¸
- `visited` : ë°©ë¬¸ ë§µ. í˜„ì¬ ì—´ë ¤ìˆëŠ” ì¢Œí‘œë¥¼ Trueë¡œ í•˜ëŠ” bool ë§µ
- `result` : í˜„ì¬ ìƒíƒœ ë§µì—ì„œ í´ë¦­í•œ ì¢Œí‘œì— ë”°ë¼ ì—´ë¦° ë§µ. (ì´ˆê¸°ê°’ : í˜„ì¬ ìƒíƒœ ë§µ)

```python
queue = deque([clicked_point])
while queue:
        x, y = queue.popleft()
        if visited[x, y]:
            continue
        visited[x, y] = True
        result[x, y] = self.map_answer[x, y]

        if self.map_answer[x,y] == 0:
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < self.nrow and 0 <= ny < self.ncol and not visited[nx, ny]:
                    queue.append((nx, ny))
```

- ì´ˆê¸° : í´ë¦­í•œ ì¢Œí‘œë§Œ `queue`ì— ë“¤ì–´ìˆìŒ (deque ìë£Œí˜•)
- `queue`ì— ëª¨ë“  ì¢Œí‘œë¥¼ íƒìƒ‰í•  ë•Œê¹Œì§€
    - `queue.popleft()` : queueì— ë“¤ì–´ìˆëŠ” ì¢Œí‘œì˜ x, yê°’ì„ ê°€ì ¸ì˜¤ë©´ì„œ ë™ì‹œì— ì œê±°í•œë‹¤.
    - ì´ë¯¸ ë°©ë¬¸í•œ ì¢Œí‘œë©´ ì¢…ë£Œ
    - ì•„ë‹ˆë¼ë©´ ë°©ë¬¸ ë§µì—ì„œ í•´ë‹¹ ì¢Œí‘œë¥¼ Trueë¡œ ë°”ê¾¸ê³ , `result` ë§µì—ì„œ í•´ë‹¹ ì¢Œí‘œë¥¼ ì—°ë‹¤.
    - ë§Œì•½ í•´ë‹¹ ì¢Œí‘œì˜ ê°’ì´ 0ì´ë¼ë©´ ì£¼ë³€ì„ íƒìƒ‰í•´ `queue`ì— ë„£ëŠ”ë‹¤.
        - ë§µ ê°€ì¥ìë¦¬ ê³ ë ¤, ë°©ë¬¸ ì—¬ë¶€ ê³ ë ¤

```python
self.visited_map = visited
```

- `self.visited_map` ì—…ë°ì´íŠ¸

## gridworld_reset

- ê·¸ë¦¬ë“œì›”ë“œ ë Œë”ë§, ì§€ë¢° ìœ„ì¹˜ ë§µ, ì •ë‹µ ë§µ, í˜„ì¬ ìƒíƒœ ë§µì„ ë¦¬ì…‹í•˜ëŠ” ë‚´ì¥ í•¨ìˆ˜.
- í´ë˜ìŠ¤ ì™¸ë¶€ì—ì„œ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ!!!

```python
def gridworld_reset(self):
    # ê·¸ë¦¬ë“œ ì›”ë“œ rendering (ì§€ë¢°: 'M')
    self.gridworld = np.full(shape=(self.nrow, self.ncol), fill_value=".")
    for x,y in self.mine_points:
        self.gridworld[x,y] = 'M'

    # ì§€ë¢° = Trueì¸ ë§µ
    self.mine_bool = (self.gridworld=='M')

    # ì£¼ë³€ ì§€ë¢° ê°œìˆ˜ë¥¼ í‘œì‹œí•œ ë§µ (ì§€ë¢° ìœ„ì¹˜: -1)
    self.map_answer = np.zeros(self.gridworld_size)
    for x,y in self.points:
        cnt = self.check_mine((x,y))
        self.map_answer[x,y] = cnt

    self.present_state = np.full((self.nrow, self.ncol), -2)
    
    # ë°©ë¬¸ ë§µ(bool)
    self.visited_map = (self.present_state == self.map_answer)
```

## move_mine

- ì—ì´ì „íŠ¸ê°€ ì²« ë²ˆì§¸ë¡œ ì„ íƒí•œ actionì´ ì§€ë¢°ì¸ ê²½ìš°, í•´ë‹¹ ì¢Œí‘œì˜ ì§€ë¢°ë¥¼ ë‹¤ë¥¸ ê³³ìœ¼ë¡œ ì˜®ê¸°ëŠ” í•¨ìˆ˜
    
    
    | input | action (Tuple) - ì¢Œí‘œ |
    | --- | --- |

```python
def move_mine(self, action:Tuple):
    empty_points = list(set(self.points) - set(self.mine_points))
    new_mine = random.sample(empty_points, 1)

    self.mine_points.remove(action)
    self.mine_points.append(new_mine[0])

    self.gridworld_reset()
```

---

```python
empty_points = list(set(self.points) - set(self.mine_points))
new_mine = random.sample(empty_points, 1)
```

- `empty_points` : ì§€ë¢°ê°€ ì—†ëŠ” ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸
    - type : `list`
- `new_mine` : `empty_points` ì—ì„œ ì¢Œí‘œ í•˜ë‚˜ë¥¼ ë½‘ì•„ ì§€ë¢°ë¡œ ì„¤ì •

```python
self.mine_points.remove(action)
self.mine_points.append(new_mine[0])

self.gridworld_reset()
```

- ì„ íƒí•œ ì¢Œí‘œë¥¼ `self.mine_points`ì—ì„œ ì œê±° í›„
- `new_mine` ì„ ì¶”ê°€
- ìƒˆë¡œìš´ `self.mine_points` ë¡œ ëª¨ë“  ë§µ ë¦¬ì…‹

# step

- ì—ì´ì „íŠ¸ê°€ ì„ íƒí•œ actionì— ë”°ë¼ ì£¼ì–´ì§€ëŠ” next_state, reward, done, clear ë¥¼ ì œê³µí•˜ëŠ” í•¨ìˆ˜
    
    
    | input | action (Tuple) - ì¢Œí‘œ |
    | --- | --- |
    | output | next_state(array), reward(int), done(bool), clear(bool) |

```python
def step(self, action:Tuple):
    x, y = action

    # ì²«ë²ˆì§¸ actionì¸ ê²½ìš°
    if np.sum(self.visted_map) == 0 :
        if action in self.mine_points:
            # ë§Œì•½ start ì¢Œí‘œì— ì§€ë¢°ê°€ ìˆëŠ” ê²½ìš° ì˜®ê¸°ê¸°
            self.move_mine(action)

    # actionì— ë”°ë¼ ê³„ì‚°ëœ state
    next_state = self.bfs_minesweeper(action)

    # actionì— ë”°ë¼ ë°”ë€ŒëŠ” ë°©ë¬¸ ë§µ(bool)
    self.visited_map = (next_state == self.map_answer)

    # ======
    # reward
    if action in self.mine_points:
        # ì§€ë¢° ë°Ÿì€ ê²½ìš° -> ì§€ë¢°ì°¾ê¸° ì‹¤íŒ¨
        # ìŒìˆ˜ì˜ ë³´ìƒê³¼ í•¨ê»˜ ì—í”¼ì†Œë“œ ì¢…ë£Œ
        reward = self.reward_dict['mine']
        done = True

    else :
        reward = self.reward_dict['empty']
        done = False

    # ======
    # ë°Ÿì§€ ì•Šì€ ì¢Œí‘œ ê°œìˆ˜ == ì§€ë¢° ê°œìˆ˜ -> ì§€ë¢°ì°¾ê¸° ì„±ê³µ
    if np.sum(self.visited_map==True) == self.num_mine:
        reward = self.reward_dict['clear']
        clear = True # ì„±ê³µí–ˆëŠ”ì§€ ì—¬ë¶€ íŒë‹¨ì„ ìœ„í•´
        done = True

    else :
        clear = False

    # í˜„ì¬ ìœ„ì¹˜ ì—…ë°ì´íŠ¸, ê²½ë¡œ ì¶”ê°€
    self.present_state = next_state

    return next_state, reward, done, clear
```

---

```python
if np.sum(self.visted_map) == 0 :
    if action in self.mine_points:
        self.move_mine(action)
```

- ì²« ë²ˆì§¸ ì•¡ì…˜ì¸ ê²½ìš°,
- í•´ë‹¹ ì¢Œí‘œê°€ ì§€ë¢°ë¼ë©´
- í•´ë‹¹ ì¢Œí‘œì˜ ì§€ë¢°ë¥¼ ë‹¤ë¥¸ ê³³ìœ¼ë¡œ ì˜®ê¸´ë‹¤.
    - `self.move_mine(ì¢Œí‘œ)` : í´ë˜ìŠ¤ ë‚´ì¥ í•¨ìˆ˜

```python
next_state = self.bfs_minesweeper(action)
```

- type : `np.array`
- ì•¡ì…˜ì— ë”°ë¼ ë°”ë€ state ë§µ
    - `self.bfs_minesweeper(ì¢Œí‘œ)` : í´ë˜ìŠ¤ ë‚´ì¥ í•¨ìˆ˜

```python
if action in self.mine_points:
    reward = self.reward_dict['mine']
    done = True

else :
    reward = self.reward_dict['empty']
    done = False
```

- ì„ íƒí•œ ì¢Œí‘œê°€ ì§€ë¢°ì¸ ê²½ìš°
    - `self.reward_dict` ì—ì„œ `â€˜mineâ€™`ì— í•´ë‹¹í•˜ëŠ” ë³´ìƒ ì œê³µ (-10)
    - `done` = True
- ì§€ë¢°ê°€ ì•„ë‹Œ ê²½ìš°
    - `self.reward_dict` ì—ì„œ `â€˜emptyâ€™`ì— í•´ë‹¹í•˜ëŠ” ë³´ìƒ ì œê³µ (+1)
    - `done` = False

```python
if np.sum(self.visited_map==True) == self.num_mine:
    reward = self.reward_dict['clear']
    clear = True # ì„±ê³µí–ˆëŠ”ì§€ ì—¬ë¶€ íŒë‹¨ì„ ìœ„í•´
    done = True

else :
    clear = False
```

- ì§€ë¢°ì°¾ê¸° ì„±ê³µ
    - ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¢Œí‘œì˜ ê°œìˆ˜ == ì§€ë¢° ê°œìˆ˜
    - `self.reward_dict` ì—ì„œ `â€˜clearâ€™`ì— í•´ë‹¹í•˜ëŠ” ë³´ìƒ ì œê³µ (+10)
    - `done` = True
    - `clear` = True
- ì§€ë¢°ì°¾ê¸° ì„±ê³µ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í•˜ë©´
    - `clear` = False
    

```python
self.present_state = next_state
```

- `self.present_state` ì—…ë°ì´íŠ¸

# reset

- ì—í”¼ì†Œë“œë§ˆë‹¤ ê²Œì„ì„ ë¦¬ì…‹í•˜ëŠ” í•¨ìˆ˜

```python
def reset(self):
    self.mine_points = random.sample(self.points, self.num_mine)
    self.gridworld_reset()
```

- ì§€ë¢° ìœ„ì¹˜ ë¦¬ì…‹, ëª¨ë“  ë§µ ë¦¬ì…‹

# ë Œë”ë§ ê´€ë ¨ í•¨ìˆ˜

## render

- ì…ë ¥ë°›ì€ state ë§µì„ ë Œë”ë§í•˜ëŠ” í•¨ìˆ˜
    
    
    | input | state(np.array) |
    | --- | --- |

```python
def render(self, state):
    render_state = np.full(shape=(self.nrow, self.ncol), fill_value=".")

    for (i,j) in self.points:
        if state[i,j] == -2:
            continue
        elif state[i,j] == -1:
            render_state[i,j] = "M"
        else:
            render_state[i,j] = state[i,j]

    render_state = pd.DataFrame(render_state)
    render_state = render_state.style.applymap(self.render_color)
    display(render_state)
```

---

```python
render_state = np.full(shape=(self.nrow, self.ncol), fill_value=".")

for (i,j) in self.points:
    if state[i,j] == -2:
        continue
    elif state[i,j] == -1:
        render_state[i,j] = "M"
    else:
        render_state[i,j] = state[i,j]
```

- ì§€ë¢°ì™€ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì •ë³´ë¥¼ ìˆ«ìë¡œ ê°€ì§€ê³  ìˆëŠ” state ë§µì„ str í˜•ì‹ìœ¼ë¡œ ë°”ê¿ˆ
    - ë°©ë¬¸í•˜ì§€ ì•Šì€ ì¢Œí‘œ : .
    - ì§€ë¢° : M
    - ì§€ë¢°ê°€ ì•„ë‹Œ ë°©ë¬¸í•œ ì¢Œí‘œ : í•´ë‹¹ ìˆ«ì
 
  ![image](https://github.com/KanghwaSisters/kanghwasisters.github.io/assets/126959470/97cad862-2058-485e-9428-ae9f6d20940c)  


```python
render_state = pd.DataFrame(render_state)
render_state = render_state.style.applymap(self.render_color)
display(render_state)
```

- `render_state` : ì¶œë ¥í•  ë§µ
    - type : `np.array` â†’ `pd.DataFrame`
    - ë¬¸ì, ìˆ«ìë§ˆì ë‹¤ë¥´ê²Œ ìƒ‰ê¹”ì„ ì…íŒë‹¤.
        - `self.render_color` : í´ë˜ìŠ¤ ë‚´ì¥ í•¨ìˆ˜

## render_answer

- ì •ë‹µ ë§µì„ ë Œë”ë§í•˜ëŠ” í•¨ìˆ˜

```python
def render_answer(self):
    render_state = np.full(shape=(self.nrow, self.ncol), fill_value=".")

    for (i,j) in self.points:
        if self.map_answer[i,j] == -1:
            render_state[i,j] = "M"
        else:
            render_state[i,j] = str(self.map_answer[i,j])

    render_state = pd.DataFrame(render_state)
    render_state = render_state.style.applymap(self.render_color)
    display(render_state)
```

## render_color

- ë Œë”ë§ ì‹œ ìƒ‰ê¹”ì„ ì…íˆëŠ” í•¨ìˆ˜

```python
def render_color(self, var):
    color = {'0':'black', '1':"skyblue", '2':'lightgreen', '3':'red', '4':'violet', '5':'brown',
             '6':'turquoise', '7':'grey', '8':'black', 'M':'white', '.':'black'}
    return f"color: {color[var]}"
```

# train ê´€ë ¨ í•¨ìˆ˜

## sample_10

- 10ê°œì˜ ê²Œì„ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“œëŠ” í•¨ìˆ˜

```python
def sample_10(self):
    sample_mine_points = []

    for i in range(10):
        self.mine_points = random.sample(self.points, self.num_mine)
        sample_mine_points.append(self.mine_points)

    return sample_mine_points
```

- ì§€ë¢° ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸ë¥¼ 10ê°œ ë§Œë“¤ì–´ ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥í•¨

## train_reset

- 10ê°œì˜ ìƒ˜í”Œë§Œì„ ì´ìš©í•´ trainí•  ë•Œ ì‚¬ìš©í•˜ëŠ” ë¦¬ì…‹ í•¨ìˆ˜
    
    
    | input | sample (list) - ì§€ë¢° ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸ì˜ ìƒ˜í”Œ |
    | --- | --- |

```python
def train_reset(self, samples:list):
    self.mine_points = random.sample(samples, 1)[0]
    self.gridworld_reset()
```

- `self.mine_points` ë¥¼ samplesì—ì„œ ë½‘ì•„ ì‚¬ìš©í•¨
